function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
import path from 'path';
import fs$1 from 'fs/promises';
import fs, { constants } from 'fs';
import { build, createServer, preview } from 'vite';
import viteReact from '@vitejs/plugin-react';
import readPkgUp from 'read-pkg-up';
import 'resolve-from';
import { isMainThread, parentPort, workerData, Worker } from 'worker_threads';
import chalk from 'chalk';
import importFresh from 'import-fresh';
import { generateHelpUrl } from '@sanity/generate-help-url';
import { createElement } from 'react';
import { renderToStaticMarkup } from 'react-dom/server';
import debugIt from 'debug';
import history from 'connect-history-api-fallback';
import chokidar from 'chokidar';
function getAliases(opts) {
  const {
    monorepo
  } = opts;
  if (!(monorepo == null ? void 0 : monorepo.path)) {
    return {};
  }
  const aliasesPath = path.resolve(monorepo.path, "dev/aliases.cjs");
  const devAliases = require(aliasesPath);
  const monorepoAliases = Object.fromEntries(Object.entries(devAliases).map(_ref => {
    let [key, modulePath] = _ref;
    return [key, path.resolve(monorepo.path, modulePath)];
  }));
  return monorepoAliases;
}
function normalizeBasePath(pathName) {
  return "/".concat(pathName, "/").replace(/^\/+/, "/").replace(/\/+$/, "/");
}
async function loadSanityMonorepo(cwd) {
  let p = cwd;
  while (p !== "/") {
    const readResult = await readPkgUp({
      cwd: p
    });
    if (!readResult) {
      return void 0;
    }
    if (readResult.packageJson.isSanityMonorepo) {
      return {
        path: path.dirname(readResult.path)
      };
    }
    p = path.dirname(path.dirname(readResult.path));
  }
  return void 0;
}
const debug$5 = debugIt("sanity:server");
const debug$4 = debug$5.extend("renderDocument");
const useThreads = typeof process.env.JEST_WORKER_ID === "undefined";
const hasWarnedAbout = /* @__PURE__ */new Set();
const defaultProps = {
  entryPath: "./.sanity/runtime/app.js"
};
const autoGeneratedWarning = "\nThis file is auto-generated from \"sanity dev\".\nModifications to this file is automatically discarded.\n\nTo customize the rendering of this file, see\n".concat(generateHelpUrl("custom-document-component"), "\n").trim();
function renderDocument(options) {
  return new Promise((resolve, reject) => {
    if (!useThreads) {
      resolve(getDocumentHtml(options.studioRootPath, options.props));
      return;
    }
    debug$4("Starting worker thread for %s", __filename);
    const worker = new Worker(__filename, {
      execArgv: void 0,
      workerData: _objectSpread(_objectSpread({}, options), {}, {
        shouldWarn: true
      })
    });
    worker.on("message", msg => {
      if (msg.type === "warning") {
        if (hasWarnedAbout.has(msg.warnKey)) {
          return;
        }
        if (Array.isArray(msg.message)) {
          msg.message.forEach(warning => console.warn("".concat(chalk.yellow("[warn]"), " ").concat(warning)));
        } else {
          console.warn("".concat(chalk.yellow("[warn]"), " ").concat(msg.message));
        }
        hasWarnedAbout.add(msg.warnKey);
        return;
      }
      if (msg.type === "error") {
        debug$4("Error from worker: %s", msg.error || "Unknown error");
        reject(new Error(msg.error || "Document rendering worker stopped with an unknown error"));
        return;
      }
      if (msg.type === "result") {
        debug$4("Document HTML rendered, %d bytes", msg.html.length);
        resolve(msg.html);
      }
    });
    worker.on("error", err => {
      debug$4("Worker errored: %s", err.message);
      reject(err);
    });
    worker.on("exit", code => {
      if (code !== 0) {
        debug$4("Worker stopped with code %d", code);
        reject(new Error("Document rendering worker stopped with exit code ".concat(code)));
      }
    });
  });
}
function decorateIndexWithAutoGeneratedWarning(template) {
  return template.replace(/<head/, "\n<!--\n".concat(autoGeneratedWarning, "\n-->\n<head"));
}
function getPossibleDocumentComponentLocations(studioRootPath) {
  return [path.join(studioRootPath, "_document.js"), path.join(studioRootPath, "_document.tsx")];
}
if (!isMainThread) {
  renderDocumentFromWorkerData();
}
function renderDocumentFromWorkerData() {
  if (!parentPort || !workerData) {
    throw new Error("Must be used as a Worker with a valid options object in worker data");
  }
  const {
    monorepo,
    studioRootPath,
    props
  } = workerData || {};
  if (typeof studioRootPath !== "string") {
    parentPort.postMessage({
      type: "error",
      message: "Missing/invalid `studioRootPath` option"
    });
    return;
  }
  if (props && typeof props !== "object") {
    parentPort.postMessage({
      type: "error",
      message: "`props` must be an object if provided"
    });
    return;
  }
  debug$4("Registering potential aliases");
  require("module-alias").addAliases(getAliases({
    monorepo
  }));
  debug$4("Registering esbuild for node %s", process.version);
  const {
    unregister
  } = require("esbuild-register/dist/node").register({
    target: "node".concat(process.version.slice(1)),
    extensions: [".jsx", ".ts", ".tsx", ".mjs"]
  });
  debug$4("Registering esbuild for .js files using jsx loader");
  const {
    unregister: unregisterJs
  } = require("esbuild-register/dist/node").register({
    target: "node".concat(process.version.slice(1)),
    extensions: [".js"],
    loader: "jsx"
  });
  const html = getDocumentHtml(studioRootPath, props);
  parentPort.postMessage({
    type: "result",
    html
  });
  unregister();
  unregisterJs();
}
function getDocumentHtml(studioRootPath, props) {
  var _a;
  const Document = getDocumentComponent(studioRootPath);
  const css = (_a = props == null ? void 0 : props.css) == null ? void 0 : _a.map(url => {
    try {
      return new URL(url).toString();
    } catch {
      return url.startsWith("/") ? url : "/".concat(url);
    }
  });
  debug$4("Rendering document component using React");
  const result = renderToStaticMarkup(createElement(Document, _objectSpread(_objectSpread(_objectSpread({}, defaultProps), props), {}, {
    css
  })));
  return "<!DOCTYPE html>".concat(result);
}
function getDocumentComponent(studioRootPath) {
  var _a;
  debug$4("Loading default document component from `sanity` module");
  const {
    DefaultDocument
  } = require("sanity");
  debug$4("Attempting to load user-defined document component from %s", studioRootPath);
  const userDefined = tryLoadDocumentComponent(studioRootPath);
  if (!userDefined) {
    debug$4("Using default document component");
    return DefaultDocument;
  }
  debug$4("Found user defined document component at %s", userDefined.path);
  const DocumentComp = userDefined.component.default;
  if (typeof DocumentComp === "function") {
    debug$4("User defined document component is a function, assuming valid");
    return DocumentComp;
  }
  debug$4("User defined document component did not have a default export");
  const userExports = Object.keys(userDefined.component).join(", ") || "None";
  const relativePath = path.relative(process.cwd(), userDefined.path);
  const typeHint = typeof userDefined.component.default === "undefined" ? "" : " (type was ".concat(typeof userDefined.component.default, ")");
  const warnKey = "".concat(relativePath, "/").concat(userDefined.modified);
  (_a = parentPort) == null ? void 0 : _a.postMessage({
    type: "warning",
    message: ["".concat(relativePath, " did not have a default export that is a React component").concat(typeHint), "Found named exports/properties: ".concat(userExports).trim(), "Using default document component from \"sanity\"."],
    warnKey
  });
  return DefaultDocument;
}
function tryLoadDocumentComponent(studioRootPath) {
  var _a;
  const locations = getPossibleDocumentComponentLocations(studioRootPath);
  for (const componentPath of locations) {
    debug$4("Trying to load document component from %s", componentPath);
    try {
      return {
        component: importFresh(componentPath),
        path: componentPath,
        modified: Math.floor((_a = fs.statSync(componentPath)) == null ? void 0 : _a.mtimeMs)
      };
    } catch (err) {
      if (err.code !== "MODULE_NOT_FOUND") {
        debug$4("Failed to load document component: %s", err.message);
        throw err;
      }
      debug$4("Document component not found at %s", componentPath);
    }
  }
  return null;
}
function sanityBuildEntries(options) {
  const {
    cwd,
    monorepo,
    basePath
  } = options;
  let entryChunkRef;
  return {
    name: "@sanity/server/build-entries",
    apply: "build",
    buildStart() {
      entryChunkRef = this.emitFile({
        type: "chunk",
        id: ".sanity/runtime/app.js",
        name: "sanity"
      });
    },
    async generateBundle(_options, outputBundle) {
      var _a, _b, _c;
      const bundle = outputBundle;
      const entryFileName = this.getFileName(entryChunkRef);
      const entryFile = bundle[entryFileName];
      if (!entryFile) {
        throw new Error("Failed to find entry file in bundle (".concat(entryFileName, ")"));
      }
      const entryPath = [basePath.replace(/\/+$/, ""), entryFileName].join("/");
      let css = [];
      if ((_a = entryFile.viteMetadata) == null ? void 0 : _a.importedCss) {
        css = [...entryFile.viteMetadata.importedCss];
        for (const key of entryFile.imports) {
          const importedCss = (_c = (_b = bundle[key]) == null ? void 0 : _b.viteMetadata) == null ? void 0 : _c.importedCss;
          if (importedCss) {
            css.push(...importedCss);
          }
        }
      }
      this.emitFile({
        type: "asset",
        fileName: "index.html",
        source: await renderDocument({
          monorepo,
          studioRootPath: cwd,
          props: {
            entryPath,
            css
          }
        })
      });
    }
  };
}
function sanityDotWorkaroundPlugin() {
  return {
    name: "@sanity/server/dot-workaround",
    configureServer(server) {
      const {
        root
      } = server.config;
      return () => {
        const handler = history({
          disableDotRule: true,
          rewrites: [{
            from: /\/index.html$/,
            to: _ref2 => {
              let {
                parsedUrl
              } = _ref2;
              const pathname = parsedUrl.pathname;
              if (pathname && fs.existsSync(path.join(root, pathname))) {
                return pathname;
              }
              return "/index.html";
            }
          }]
        });
        server.middlewares.use((req, res, next) => {
          handler(req, res, next);
        });
      };
    }
  };
}
function sanityRuntimeRewritePlugin() {
  return {
    name: "@sanity/server/sanity-runtime-rewrite",
    apply: "serve",
    configureServer(viteDevServer) {
      return () => {
        viteDevServer.middlewares.use((req, res, next) => {
          if (req.url === "/index.html") {
            req.url = "/.sanity/runtime/index.html";
          }
          next();
        });
      };
    }
  };
}
function generateWebManifest(basePath) {
  return {
    icons: [{
      src: "".concat(basePath, "/favicon-192.png"),
      type: "image/png",
      sizes: "192x192"
    }, {
      src: "".concat(basePath, "/favicon-512.png"),
      type: "image/png",
      sizes: "512x512"
    }]
  };
}
const mimeTypes = {
  ".ico": "image/x-icon",
  ".svg": "image/svg+xml",
  ".png": "image/png"
};
function sanityFaviconsPlugin(_ref3) {
  let {
    faviconsPath,
    staticUrlPath
  } = _ref3;
  const cache = {};
  async function getFavicons() {
    if (cache.favicons) {
      return cache.favicons;
    }
    cache.favicons = await fs$1.readdir(faviconsPath);
    return cache.favicons;
  }
  return {
    name: "@sanity/server/sanity-favicons",
    apply: "serve",
    configureServer(viteDevServer) {
      const webManifest = JSON.stringify(generateWebManifest(staticUrlPath), null, 2);
      const webManifestPath = "".concat(staticUrlPath, "/manifest.webmanifest");
      return () => {
        viteDevServer.middlewares.use(async (req, res, next) => {
          var _a;
          if ((_a = req.url) == null ? void 0 : _a.endsWith(webManifestPath)) {
            res.writeHead(200, "OK", {
              "content-type": "application/manifest+json"
            });
            res.write(webManifest);
            res.end();
            return;
          }
          const parsedUrl = req._parsedUrl || new URL(req.url || "/", "http://localhost:3333");
          const icons = await getFavicons();
          const fileName = path.basename(parsedUrl.pathname || "");
          if (!icons.includes(fileName)) {
            next();
            return;
          }
          const mimeType = mimeTypes[path.extname(fileName)] || "application/octet-stream";
          res.writeHead(200, "OK", {
            "content-type": mimeType
          });
          res.write(await fs$1.readFile(path.join(faviconsPath, fileName)));
          res.end();
        });
      };
    }
  };
}
async function getViteConfig(options) {
  const {
    cwd,
    mode,
    outputDir,
    sourceMap = options.mode === "development",
    server,
    minify,
    basePath: rawBasePath = "/"
  } = options;
  const monorepo = await loadSanityMonorepo(cwd);
  const basePath = normalizeBasePath(rawBasePath);
  const faviconsPath = path.resolve(__dirname, "../static/favicons");
  const staticPath = "".concat(basePath, "static");
  const viteConfig = {
    cacheDir: "node_modules/.sanity/vite",
    root: cwd,
    base: basePath,
    build: {
      outDir: outputDir || path.resolve(cwd, "dist"),
      sourcemap: sourceMap
    },
    server: {
      base: basePath,
      host: server == null ? void 0 : server.host,
      port: (server == null ? void 0 : server.port) || 3333,
      strictPort: true
    },
    configFile: false,
    mode,
    plugins: [viteReact(), sanityFaviconsPlugin({
      faviconsPath,
      staticUrlPath: staticPath
    }), sanityDotWorkaroundPlugin(), sanityRuntimeRewritePlugin(), sanityBuildEntries({
      basePath,
      cwd,
      monorepo
    })],
    envPrefix: "SANITY_STUDIO_",
    logLevel: mode === "production" ? "silent" : "info",
    resolve: {
      alias: getAliases({
        monorepo
      })
    },
    define: {
      __SANITY_STAGING__: process.env.SANITY_INTERNAL_ENV === "staging"
    }
  };
  if (mode === "production") {
    viteConfig.build = _objectSpread(_objectSpread({}, viteConfig.build), {}, {
      assetsDir: "static",
      minify: minify ? "esbuild" : false,
      emptyOutDir: false,
      rollupOptions: {
        input: {
          sanity: path.join(cwd, ".sanity", "runtime", "app.js")
        }
      }
    });
  }
  return viteConfig;
}
function finalizeViteConfig(config) {
  var _a, _b;
  if (typeof ((_b = (_a = config.build) == null ? void 0 : _a.rollupOptions) == null ? void 0 : _b.input) !== "object") {
    throw new Error("Vite config must contain `build.rollupOptions.input`, and it must be an object");
  }
  if (!config.root) {
    throw new Error("Vite config must contain `root` property, and must point to the Sanity root directory");
  }
  return _objectSpread(_objectSpread({}, config), {}, {
    build: _objectSpread(_objectSpread({}, config.build), {}, {
      rollupOptions: _objectSpread(_objectSpread({}, config.build.rollupOptions), {}, {
        input: _objectSpread(_objectSpread({}, config.build.rollupOptions.input), {}, {
          sanity: path.join(config.root, ".sanity", "runtime", "app.js")
        })
      })
    })
  });
}
const entryModule = "\n// This file is auto-generated on 'sanity dev'\n// Modifications to this file is automatically discarded\nimport {renderStudio} from \"sanity\"\nimport studioConfig from %STUDIO_CONFIG_LOCATION%\n\nrenderStudio(\n  document.getElementById(\"sanity\"),\n  studioConfig,\n  %STUDIO_REACT_STRICT_MODE%\n)\n";
function getEntryModule(options) {
  return entryModule.replace(/%STUDIO_REACT_STRICT_MODE%/, JSON.stringify(Boolean(options.reactStrictMode))).replace(/%STUDIO_CONFIG_LOCATION%/, JSON.stringify(options.relativeConfigLocation));
}
const debug$3 = debug$5.extend("config");
async function getSanityStudioConfigPath(studioRootPath) {
  const configPaths = [path.join(studioRootPath, "sanity.config.mjs"), path.join(studioRootPath, "sanity.config.js"), path.join(studioRootPath, "sanity.config.ts"), path.join(studioRootPath, "sanity.config.jsx"), path.join(studioRootPath, "sanity.config.tsx")];
  debug$3("Looking for configuration file in %d possible locations", configPaths.length);
  const configs = await Promise.all(configPaths.map(async configPath => ({
    path: configPath,
    exists: await fileExists(configPath)
  })));
  const availableConfigs = configs.filter(config => config.exists);
  debug$3("Found %d available configuration files", availableConfigs.length);
  if (availableConfigs.length === 0) {
    console.warn("No `sanity.config.js`/`sanity.config.ts` found - using default studio config");
    return path.resolve(__dirname, "./default-config.js");
  }
  if (availableConfigs.length > 1) {
    console.warn("Found multiple potential studio configs:");
    availableConfigs.forEach(config => console.warn(" - ".concat(config.path)));
    console.warn("Using ".concat(availableConfigs[0].path));
  }
  return availableConfigs[0].path;
}
function fileExists(filePath) {
  return fs$1.stat(filePath).then(() => true, () => false);
}
const debug$2 = debug$5.extend("runtime");
async function writeSanityRuntime(_ref4) {
  let {
    cwd,
    reactStrictMode,
    watch
  } = _ref4;
  debug$2("Resolving Sanity monorepo information");
  const monorepo = await loadSanityMonorepo(cwd);
  const runtimeDir = path.join(cwd, ".sanity", "runtime");
  debug$2("Making runtime directory");
  await fs$1.mkdir(runtimeDir, {
    recursive: true
  });
  async function renderAndWriteDocument() {
    debug$2("Rendering document template");
    const indexHtml = decorateIndexWithAutoGeneratedWarning(await renderDocument({
      studioRootPath: cwd,
      monorepo,
      props: {
        entryPath: "/".concat(path.relative(cwd, path.join(runtimeDir, "app.js")))
      }
    }));
    debug$2("Writing index.html to runtime directory");
    await fs$1.writeFile(path.join(runtimeDir, "index.html"), indexHtml);
  }
  if (watch) {
    chokidar.watch(getPossibleDocumentComponentLocations(cwd)).on("all", () => renderAndWriteDocument());
  }
  await renderAndWriteDocument();
  debug$2("Writing app.js to runtime directory");
  const studioConfigPath = await getSanityStudioConfigPath(cwd);
  const relativeConfigLocation = path.relative(runtimeDir, studioConfigPath);
  await fs$1.writeFile(path.join(runtimeDir, "app.js"), getEntryModule({
    reactStrictMode,
    relativeConfigLocation
  }));
}
const debug$1 = debug$5.extend("static");
async function buildStaticFiles(options) {
  const {
    cwd,
    outputDir,
    sourceMap = false,
    minify = true,
    basePath,
    vite: extendViteConfig
  } = options;
  debug$1("Writing Sanity runtime files");
  await writeSanityRuntime({
    cwd,
    reactStrictMode: false,
    watch: false
  });
  debug$1("Resolving vite config");
  let viteConfig = await getViteConfig({
    cwd,
    basePath,
    outputDir,
    minify,
    sourceMap,
    mode: "production"
  });
  if (extendViteConfig) {
    debug$1("Extending vite config with user-specified config");
    viteConfig = finalizeViteConfig(extendViteConfig(viteConfig));
  }
  debug$1("Copying static files from /static to output dir");
  const staticPath = path.join(outputDir, "static");
  await copyDir(path.join(cwd, "static"), staticPath);
  debug$1("Writing favicons to output dir");
  const faviconBasePath = "".concat(basePath.replace(/\/+$/, ""), "/static");
  await writeFavicons(faviconBasePath, staticPath);
  debug$1("Bundling using vite");
  const bundle = await build(viteConfig);
  debug$1("Bundling complete");
  if (Array.isArray(bundle) || !("output" in bundle)) {
    return {
      chunks: []
    };
  }
  const stats = [];
  bundle.output.forEach(chunk => {
    if (chunk.type !== "chunk") {
      return;
    }
    stats.push({
      name: chunk.name,
      modules: Object.entries(chunk.modules).map(_ref5 => {
        let [rawFilePath, chunkModule] = _ref5;
        const filePath = rawFilePath.startsWith("\0") ? rawFilePath.slice("\0".length) : rawFilePath;
        return {
          name: path.isAbsolute(filePath) ? path.relative(cwd, filePath) : filePath,
          originalLength: chunkModule.originalLength,
          renderedLength: chunkModule.renderedLength
        };
      })
    });
  });
  return {
    chunks: stats
  };
}
async function copyDir(srcDir, destDir, skipExisting) {
  await fs$1.mkdir(destDir, {
    recursive: true
  });
  for (const file of await tryReadDir(srcDir)) {
    const srcFile = path.resolve(srcDir, file);
    if (srcFile === destDir) {
      continue;
    }
    const destFile = path.resolve(destDir, file);
    const stat = await fs$1.stat(srcFile);
    if (stat.isDirectory()) {
      await copyDir(srcFile, destFile, skipExisting);
    } else if (skipExisting) {
      await fs$1.copyFile(srcFile, destFile, constants.COPYFILE_EXCL).catch(skipIfExistsError);
    } else {
      await fs$1.copyFile(srcFile, destFile);
    }
  }
}
async function tryReadDir(dir) {
  try {
    const content = await fs$1.readdir(dir);
    return content;
  } catch (err) {
    if (err.code === "ENOENT") {
      return [];
    }
    throw err;
  }
}
function skipIfExistsError(err) {
  if (err.code === "EEXIST") {
    return;
  }
  throw err;
}
async function writeFavicons(basePath, destDir) {
  await fs$1.mkdir(destDir, {
    recursive: true
  });
  await copyDir(path.resolve(__dirname, "../static/favicons"), destDir, true);
  await writeWebManifest(basePath, destDir);
}
async function writeWebManifest(basePath, destDir) {
  const content = JSON.stringify(generateWebManifest(basePath), null, 2);
  await fs$1.writeFile(path.join(destDir, "manifest.webmanifest"), content, "utf8").catch(skipIfExistsError);
}
async function startDevServer(options) {
  const {
    cwd,
    httpPort,
    httpHost,
    basePath: base,
    reactStrictMode,
    vite: extendViteConfig
  } = options;
  const startTime = Date.now();
  debug$5("Writing Sanity runtime files");
  await writeSanityRuntime({
    cwd,
    reactStrictMode,
    watch: true
  });
  debug$5("Resolving vite config");
  let viteConfig = await getViteConfig({
    basePath: base || "/",
    mode: "development",
    server: {
      port: httpPort,
      host: httpHost
    },
    cwd
  });
  if (extendViteConfig) {
    debug$5("Extending vite config using user-specified function");
    viteConfig = extendViteConfig(viteConfig);
  }
  debug$5("Creating vite server");
  const server = await createServer(viteConfig);
  const info = server.config.logger.info;
  debug$5("Listening on specified port");
  await server.listen();
  const startupDuration = Date.now() - startTime;
  const url = "http://".concat(httpHost || "localhost", ":").concat(httpPort || "3333");
  info("Sanity Studio using ".concat(chalk.cyan("vite@".concat(require("vite/package.json").version)), " ready in ").concat(chalk.cyan("".concat(Math.ceil(startupDuration), "ms")), " and running at ").concat(chalk.cyan(url)));
  return {
    close: () => server.close()
  };
}
const debug = debug$5.extend("preview");
async function startPreviewServer(options) {
  const {
    httpPort,
    httpHost,
    basePath: base,
    root
  } = options;
  const startTime = Date.now();
  if (!fs.existsSync(path.join(root, "index.html"))) {
    const err = new Error("Could not find a production build in the '".concat(root, "' directory. Try building your studio app with 'sanity build' before starting the preview server."));
    err.name = "BUILD_NOT_FOUND";
    throw err;
  }
  const previewConfig = {
    root,
    base: base || "/",
    configFile: false,
    preview: {
      port: httpPort,
      host: httpHost,
      strictPort: true
    },
    build: {
      outDir: root
    }
  };
  debug("Creating vite server");
  const server = await preview(previewConfig);
  const info = server.config.logger.info;
  const url = server.resolvedUrls.local[0];
  const startupDuration = Date.now() - startTime;
  info("Sanity Studio using ".concat(chalk.cyan("vite@".concat(require("vite/package.json").version)), " ready in ").concat(chalk.cyan("".concat(Math.ceil(startupDuration), "ms")), " and running at ").concat(chalk.cyan(url), " (production preview mode)"));
  return {
    urls: server.resolvedUrls,
    close: () => new Promise((resolve, reject) => server.httpServer.close(err => err ? reject(err) : resolve()))
  };
}
export { buildStaticFiles, getSanityStudioConfigPath, startDevServer, startPreviewServer };
//# sourceMappingURL=index.esm.js.map
