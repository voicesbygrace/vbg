'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
var child_process = require('child_process');
var fs = require('fs/promises');
var path = require('path');
var yargs = require('yargs/yargs');
var helpers = require('yargs/helpers');
var readPkgUp = require('read-pkg-up');
function _interopDefaultLegacy(e) {
  return e && typeof e === 'object' && 'default' in e ? e : {
    'default': e
  };
}
var fs__default = /*#__PURE__*/_interopDefaultLegacy(fs);
var path__default = /*#__PURE__*/_interopDefaultLegacy(path);
var yargs__default = /*#__PURE__*/_interopDefaultLegacy(yargs);
var readPkgUp__default = /*#__PURE__*/_interopDefaultLegacy(readPkgUp);
function parseCliFlags(args) {
  return yargs__default["default"](helpers.hideBin(args.argv || process.argv)).command("exec [script]", "executes given script", cmd => cmd.positional("script", {
    type: "string",
    demandOption: true
  }).option("with-user-token", {
    type: "boolean",
    default: false
  }).option("mock-browser-env", {
    type: "boolean",
    default: false
  })).argv;
}
const execScript = async function execScript2(args, context) {
  var _a;
  const {
    withUserToken,
    mockBrowserEnv,
    script
  } = await parseCliFlags(args);
  const {
    workDir
  } = context;
  const scriptPath = path__default["default"].resolve(script || "");
  if (!script) {
    throw new Error("SCRIPT must be provided. `sanity exec <script>`");
  }
  if (!(await fs__default["default"].stat(scriptPath).catch(() => false))) {
    throw new Error("".concat(scriptPath, " does not exist"));
  }
  const sanityPkgPath = (_a = await readPkgUp__default["default"]({
    cwd: __dirname
  })) == null ? void 0 : _a.path;
  if (!sanityPkgPath) {
    throw new Error("Unable to resolve `sanity` module root");
  }
  const sanityDir = path__default["default"].dirname(sanityPkgPath);
  const threadsDir = path__default["default"].join(sanityDir, "lib", "_internal", "cli", "threads");
  const esbuildPath = path__default["default"].join(threadsDir, "esbuild.js");
  const browserEnvPath = path__default["default"].join(threadsDir, "registerBrowserEnv.js");
  const configClientPath = path__default["default"].join(threadsDir, "configClient.js");
  if (!(await fs__default["default"].stat(esbuildPath).catch(() => false))) {
    throw new Error("`sanity` module build error: missing threads");
  }
  const baseArgs = mockBrowserEnv ? ["-r", browserEnvPath] : ["-r", esbuildPath];
  const tokenArgs = withUserToken ? ["-r", configClientPath] : [];
  const nodeArgs = [...baseArgs, ...tokenArgs, scriptPath, ...args.extraArguments];
  const proc = child_process.spawn(process.argv[0], nodeArgs, {
    stdio: "inherit",
    env: _objectSpread(_objectSpread({}, process.env), {}, {
      SANITY_BASE_PATH: workDir
    })
  });
  proc.on("close", process.exit);
};
exports["default"] = execScript;
//# sourceMappingURL=execScript-6f579c4d.js.map
