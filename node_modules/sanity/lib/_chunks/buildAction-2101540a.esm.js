function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
import path from 'path';
import { promisify } from 'util';
import { buildStaticFiles } from '@sanity/server';
import chalk from 'chalk';
import rimrafCallback from 'rimraf';
import { c as checkStudioDependencyVersions, a as checkRequiredDependencies, g as getTimer } from './timing-033daeeb.esm.js';
import 'fs';
import 'semver';
import 'resolve-from';
import '@sanity/generate-help-url';
import 'fs/promises';
import 'execa';
import 'oneline';
import 'perf_hooks';
const rimraf = promisify(rimrafCallback);
async function buildSanityStudio(args, context, overrides) {
  var _a;
  const timer = getTimer();
  const {
    output,
    prompt,
    workDir,
    cliConfig
  } = context;
  const flags = _objectSpread({
    minify: true,
    stats: false,
    "source-maps": false
  }, args.extOptions);
  const unattendedMode = Boolean(flags.yes || flags.y);
  const defaultOutputDir = path.resolve(path.join(workDir, "dist"));
  const outputDir = path.resolve(args.argsWithoutOptions[0] || defaultOutputDir);
  await checkStudioDependencyVersions(workDir);
  if ((await checkRequiredDependencies(context)).didInstall) {
    return {
      didCompile: false
    };
  }
  const envVarKeys = getSanityEnvVars();
  if (envVarKeys.length > 0) {
    output.print("\nIncluding the following environment variables as part of the JavaScript bundle:");
    envVarKeys.forEach(key => output.print("- ".concat(key)));
    output.print("");
  }
  let shouldClean = true;
  if (outputDir !== defaultOutputDir && !unattendedMode) {
    shouldClean = await prompt.single({
      type: "confirm",
      message: "Do you want to delete the existing directory (".concat(outputDir, ") first?"),
      default: true
    });
  }
  let spin;
  if (shouldClean) {
    timer.start("cleanOutputFolder");
    spin = output.spinner("Clean output folder").start();
    await rimraf(outputDir);
    const cleanDuration = timer.end("cleanOutputFolder");
    spin.text = "Clean output folder (".concat(cleanDuration.toFixed(), "ms)");
    spin.succeed();
  }
  spin = output.spinner("Build Sanity Studio").start();
  try {
    timer.start("bundleStudio");
    const bundle = await buildStaticFiles({
      cwd: workDir,
      outputDir,
      basePath: (overrides == null ? void 0 : overrides.basePath) || ((_a = cliConfig == null ? void 0 : cliConfig.project) == null ? void 0 : _a.basePath) || "/",
      sourceMap: Boolean(flags["source-maps"]),
      minify: Boolean(flags.minify),
      vite: cliConfig && "vite" in cliConfig ? cliConfig.vite : void 0
    });
    const buildDuration = timer.end("bundleStudio");
    spin.text = "Build Sanity Studio (".concat(buildDuration.toFixed(), "ms)");
    spin.succeed();
    if (flags.stats) {
      output.print("\nLargest module files:");
      output.print(formatModuleSizes(sortModulesBySize(bundle.chunks).slice(0, 15)));
    }
  } catch (err) {
    spin.fail();
    throw err;
  }
  return {
    didCompile: true
  };
}
function getSanityEnvVars() {
  let env = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : process.env;
  return Object.keys(env).filter(key => key.toUpperCase().startsWith("SANITY_STUDIO_"));
}
function sortModulesBySize(chunks) {
  return chunks.flatMap(chunk => chunk.modules).sort((modA, modB) => modB.renderedLength - modA.renderedLength);
}
function formatModuleSizes(modules) {
  const lines = [];
  for (const mod of modules) {
    lines.push(" - ".concat(formatModuleName(mod.name), " (").concat(formatSize(mod.renderedLength), ")"));
  }
  return lines.join("\n");
}
function formatModuleName(modName) {
  const delimiter = "/node_modules/";
  const nodeIndex = modName.lastIndexOf(delimiter);
  return nodeIndex === -1 ? modName : modName.slice(nodeIndex + delimiter.length);
}
function formatSize(bytes) {
  return chalk.cyan("".concat((bytes / 1024).toFixed(), " kB"));
}
export { buildSanityStudio as default };
//# sourceMappingURL=buildAction-2101540a.esm.js.map
