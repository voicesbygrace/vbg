'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
var path = require('path');
var util = require('util');
var server = require('@sanity/server');
var chalk = require('chalk');
var rimrafCallback = require('rimraf');
var timing = require('./timing-a407497b.js');
require('fs');
require('semver');
require('resolve-from');
require('@sanity/generate-help-url');
require('fs/promises');
require('execa');
require('oneline');
require('perf_hooks');
function _interopDefaultLegacy(e) {
  return e && typeof e === 'object' && 'default' in e ? e : {
    'default': e
  };
}
var path__default = /*#__PURE__*/_interopDefaultLegacy(path);
var chalk__default = /*#__PURE__*/_interopDefaultLegacy(chalk);
var rimrafCallback__default = /*#__PURE__*/_interopDefaultLegacy(rimrafCallback);
const rimraf = util.promisify(rimrafCallback__default["default"]);
async function buildSanityStudio(args, context, overrides) {
  var _a;
  const timer = timing.getTimer();
  const {
    output,
    prompt,
    workDir,
    cliConfig
  } = context;
  const flags = _objectSpread({
    minify: true,
    stats: false,
    "source-maps": false
  }, args.extOptions);
  const unattendedMode = Boolean(flags.yes || flags.y);
  const defaultOutputDir = path__default["default"].resolve(path__default["default"].join(workDir, "dist"));
  const outputDir = path__default["default"].resolve(args.argsWithoutOptions[0] || defaultOutputDir);
  await timing.checkStudioDependencyVersions(workDir);
  if ((await timing.checkRequiredDependencies(context)).didInstall) {
    return {
      didCompile: false
    };
  }
  const envVarKeys = getSanityEnvVars();
  if (envVarKeys.length > 0) {
    output.print("\nIncluding the following environment variables as part of the JavaScript bundle:");
    envVarKeys.forEach(key => output.print("- ".concat(key)));
    output.print("");
  }
  let shouldClean = true;
  if (outputDir !== defaultOutputDir && !unattendedMode) {
    shouldClean = await prompt.single({
      type: "confirm",
      message: "Do you want to delete the existing directory (".concat(outputDir, ") first?"),
      default: true
    });
  }
  let spin;
  if (shouldClean) {
    timer.start("cleanOutputFolder");
    spin = output.spinner("Clean output folder").start();
    await rimraf(outputDir);
    const cleanDuration = timer.end("cleanOutputFolder");
    spin.text = "Clean output folder (".concat(cleanDuration.toFixed(), "ms)");
    spin.succeed();
  }
  spin = output.spinner("Build Sanity Studio").start();
  try {
    timer.start("bundleStudio");
    const bundle = await server.buildStaticFiles({
      cwd: workDir,
      outputDir,
      basePath: (overrides == null ? void 0 : overrides.basePath) || ((_a = cliConfig == null ? void 0 : cliConfig.project) == null ? void 0 : _a.basePath) || "/",
      sourceMap: Boolean(flags["source-maps"]),
      minify: Boolean(flags.minify),
      vite: cliConfig && "vite" in cliConfig ? cliConfig.vite : void 0
    });
    const buildDuration = timer.end("bundleStudio");
    spin.text = "Build Sanity Studio (".concat(buildDuration.toFixed(), "ms)");
    spin.succeed();
    if (flags.stats) {
      output.print("\nLargest module files:");
      output.print(formatModuleSizes(sortModulesBySize(bundle.chunks).slice(0, 15)));
    }
  } catch (err) {
    spin.fail();
    throw err;
  }
  return {
    didCompile: true
  };
}
function getSanityEnvVars() {
  let env = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : process.env;
  return Object.keys(env).filter(key => key.toUpperCase().startsWith("SANITY_STUDIO_"));
}
function sortModulesBySize(chunks) {
  return chunks.flatMap(chunk => chunk.modules).sort((modA, modB) => modB.renderedLength - modA.renderedLength);
}
function formatModuleSizes(modules) {
  const lines = [];
  for (const mod of modules) {
    lines.push(" - ".concat(formatModuleName(mod.name), " (").concat(formatSize(mod.renderedLength), ")"));
  }
  return lines.join("\n");
}
function formatModuleName(modName) {
  const delimiter = "/node_modules/";
  const nodeIndex = modName.lastIndexOf(delimiter);
  return nodeIndex === -1 ? modName : modName.slice(nodeIndex + delimiter.length);
}
function formatSize(bytes) {
  return chalk__default["default"].cyan("".concat((bytes / 1024).toFixed(), " kB"));
}
exports["default"] = buildSanityStudio;
//# sourceMappingURL=buildAction-cb34042f.js.map
